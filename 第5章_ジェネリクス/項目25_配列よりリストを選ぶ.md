# 項目25 配列よりリストを選ぶ

配列とジェネリクス型では大きく２つの点で異なっている。

* 配列は **共変** であり、ジェネリクス型は **不変** である。
* 配列は **具象化** されており、ジェネリクス型は **イレイジャ** である。


## 配列は 共変 であり、ジェネリクス型は 不変 である

`String` と `Object` を例に挙げて説明すると、
`String` は `Object` のサブクラスなので `String[]` は　`Object[]` として振る舞うことが出来る。  
これを **共変** という。

しかしジェネリクス型の場合、`List<String>` は `List<Object>` として振る舞うことができない。  
「`String` は `Object` のサブクラス」という関係性があったとしても、`List<String>` と `List<Object>` の間には何の関係もない。  
これを **不変** という。

```java
// 配列は共変
Object[] objects = new String[10];
object[0] = Integer.valueOf(1);  // コンパイルは通るが、実行時エラー。（ArrayStoreExceptionがスローされる）

// ジェネリクス型は不変
List<Object> objectList = new ArrayList<String>(); // これはコンパイルエラー
objectList.add(Integer.valueOf(1));
```

上記のコードは、どっちも `String` の入れ物に対して `Integer` を入れることが出来ないが、
前者（配列）は実行しないと誤りに気づくことができない。


## 配列は 具象化 されており、ジェネリクス型は イレイジャ である

配列は自身が扱う要素の型情報を知っている（具象化された型を強要する）のに対し、
ジェネリクス型は実行時に型情報が削除される **イレイジャ** として実装されているので、コンパイル後は原型となる。（原型については、項目23を参照）  
※イレイジャとして実装されている理由は、ジェネリクスが導入されてなかった1.4以前のコードと相互運用可能にするため。


これらの基本的な相違によって、配列とジェネリクスは上手く調和しない。  
そのため、以下のような配列は生成することができない。

* ジェネリクス型の配列
  * `new List<T>[]`
* パラメータ化された型の配列
  * `new List<String>[]`
* 型パラメータの配列
  * `new T[]`


ただし、変数や戻り値の宣言として型パラメータの配列などを利用することは可能。

```java
// パラメータ化された配列の変数の宣言は可能。
private T[] array;

// 戻り値として、型パラメータの配列を定義することも可能。
T[] getArray() {
    return this.array;
}

// 引数として、型パラメータの配列を定義することも可能。
void setArray(T[] array) {
    this.array = array;
}
```


## ジェネリクスの配列が許可されてない理由

ジェネリクスの配列が許可されていないのは、**型安全ではない** ため。  
もしもジェネリクスの配列が許可されいるとすれば、実行時に `ClassCastException` が発生してしまう可能性がある。

ジェネリクスの配列が許可されているとどうなるのか、以下に例を記載する。

```java
// ジェネリクス型の配列が許可されていると仮定した場合の危険なコード
List<String>[] stringList = new ArrayList<>[1];        // (1)
List<Integer> intList = List.of(Integer.valueOf(1));   // (2)

Object[] objects = stringList;                         // (3)
objects[0] = intList;                                  // (4)
String s = stringlist[0].get(0);                       // (5)
```

(1)~(2)ではList型の配列を定義しているだけ。  
次に (3) で、`Object[]` に対して `List<String>[]` を代入している。  
`Object` は全てのクラスのスーパクラスであり、配列は *共変* であるため代入することは問題ない。  

(4) では、`List<Integer>` を `Object` に代入しているが、
ジェネリクスはイレイジャ実装によって型情報が削除されるため、単なる `List` が `Object` に代入されることになる。  
また、(3) で `Object[]` に `List<String>[]` を代入していたが、`List<Integer>` と同じように、
実行時には型情報が消えるため `List[]` を代入していることになる。  
`List[]` に `List` の値を入れてもエラーにはならないので、実行時に `ArrayStoreException` はスローされない。


そして (5) で、`List<String>[]` から値を取得しており、コンパイラによって `String` へのキャストが自動的に行われる。  
しかし、実際に格納されているのは `Integer` であるため `ClassCastException` がスローされる。


上記のコードをコンパイルすると以下のようなコードが生成されることになる。

```java
// コンパイル後のコード
List[] stringList = new ArrayList[1];         // 単なる List[] 型のインスタンス
List intList = List.of(Integer.valueOf(1));   // 単なる List 型のインスタンス

Object[] objects = stringList;                // List は Object のサブクラスなので、Object[] に List[] が代入可能
objects[0] = intList;                         // List[] に List は格納できる
String s = (String)stringlist[0].get(0);      // 実際 tringList[0] には List<Integer> が格納されているので キャストに失敗する。
```


## 具象不可能型

`E`、`List<E>`、`List<String>` は **具象不可能型** と呼ばれており、
「コンパイル時の表現よりも、実行時の表現の方が情報が少ない型」のこと。（ジェネリクスは具象化不可能型）

ただし、非境界値ワイルドカード型（`Map<?, ?>` や `List<?>`）は具象化可能で、
非境界値ワイルドカード型の配列の生成は許されている。

```java
// これはコンパイルできる
List<?>[] lists = new ArrayList<?>[1];
```

## ジェネリクス型の配列を生成できないことによるデメリット

デメリットとしては以下があげられる。

* ジェネリクス型のコレクションを、その要素型の配列に変換できない。（項目29）
  * `List<String>#toArray` は、`Object[]` を返す。
  * これはジェネリクスがイレイジャ実装によって、型情報が削除されていることに起因する。
* 可変長引数を、ジェネリクス型のコレクションと組み合わせて使用する場合に不都合が起きる （項目42）
  * 可変長引数のメソッドでジェネリック型を使用した場合、警告が発生する。
  * `void mehotd(T...args){}` というメソッドを定義してコンパイルすると警告が出る。


上記のように配列とジェネリクスは相性が悪いので、多くの場合は配列よりもリストを使用すべき。