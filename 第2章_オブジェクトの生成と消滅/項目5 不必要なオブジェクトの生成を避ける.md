# 第2章 オブジェクトの生成と消滅

## 項目5 不必要なオブジェクトの生成を避ける

機能的に同じオブジェクトが必要となった場合、新規に生成するよりも１つのオブジェクトを再利用する方が適切。<br/>
オブジェクトが不変であれば、常に再利用が可能。

例えば、

```java
String msg = new String("Message");
```

これはやってはいけないパターンの一つ。<br/>
`String`は不変オブジェクトであり、実行される度に`String`インスタンスが生成されてしまう。<br/>
本来は、

```java
String msg = "Message";
```

と書く方が適切であり、同一JVMで定義された文字リテラルは再利用されることが保証されている。

```java
String strA = "1";
String strB = "1";
String strC = new String("1");

// strA と strB は、同一インスタンス扱いとなる。
// strC は別インスタンス扱い。
```

コンストラクタとstaticファクトリメソッドを提供している不変クラスでは、`staticファクトリメソッド`を使用することで不要なオブジェクトの生成を抑制することができる。<br/>
単に、内部的にインスタンスをキャッシュして、パラメータに一致するインスタンスを返却すればよいだけ。<br/>

例えば`Integer`は、内部で -128〜127 までの`Integer`インスタンスをキャッシュしています。<br/>
`Integer#valueOf`メソッドに指定された値が -128~127であれば、キャッシュしたインスタンスを返却し、それ以外であれば新たに生成した（コンストラクタを呼び出して）インスタンスを返却します。

### コストの高いオブジェクトの生成には注意する。

特にコストの高いオブジェクトの生成については、気にする必要がある。（例えば、`Date` クラスや `Calendaor` クラスなど。<br/>
毎回生成する必要のないオブジェクトは、staticイニシャライザで初回のみ生成するなどの工夫が必要。<br/>

```java
// ダメな例
public class Person {
    private final Date birthDate;

    // ベビーブーム期に生まれたか否かを判定する
    public boolean isBabyBoomer(){
        Calendar c = Calendar.getInstance();
        
        c.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomStart = c.getTime();
        
        c.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomEnd = c.getTime();
        
        return birthDate.compareTo(boomStart) >= 0 && birthDate.compareTo(boomEnd) < 0);
    }
}
```

```java
// 良い例
    private final Date birthDate;
    
    private final Date BOOM_START;
    private final Date BOOM_END;

    static {
        Calendar c = Calendar.getInstance();
        c.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_START = c.getTime();
        c.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_END = c.getTime();
    }

    public boolean isBabyBoomer(){
        return birthDate.compareTo(BOOM_START) >= 0 && birthDate.compareTo(BOOM_END) < 0);
    }
```

---

また、必要になったときに初めてオブジェクトを生成する **遅延初期化** 採用する方法もある。<br/>
メリットとしては、必要になった時に初めてオブジェクトが生成されるため、メモリの節約になる点。<br/>
デメリットとしては、実装が複雑になってしまう点。<br/>


### 自動ボクシングについて

* プリミティブ型のラッパークラスとプリミティブ型混在させることができる仕様のこと。
* セマンティック（意味合い的に）上は微妙な違いだが、パフォーマンス上は大きな違いがある。

```java
Long sum = 0L;
for(long i = 0; i < Integer.MAX_VALUE; i++){
	sum += i;
}
System.out.println(sum);
```

* 上記のプログラムは、変数 `sum` が `long` ではなく `Long` で宣言されていることにより、非常に遅い。
* そのため、プログラム的に `Long` インスタンスを 2 ^ 31 個生成していることになる。
* 変数 `sum` を `Long` から `long` にするだけで圧倒的に早くなる。
 * 自分のマシンだと、約10秒が１秒に減った。（ざっと１０倍）
* 自動ボクシングは不要なオブジェクトを生成する。
* そのため、オートボクシングされたプリミティブ型よりも、ボクシングされていないプリミティブ型を選択する。
* また、意図しないボクシングに注意すること。

###  オブジェクトの生成について

* この項は「オブジェクト生成はコストがかかるため、避ける」ことを意味しているわけではない。
* 小さなオブジェクトの生成であれば、特に問題はない。（JVMがいい感じにしてくれる）
* 逆に、**オブジェクトプール**を自前で管理するのは、プール対象のオブジェクトの生成コストが非常に重いもので無い場合、悪い考え。
* オブジェクトプールが正当化されている代表例が**DBのコネクション**。
 * 一般的にDBのコネクションの確立はコストが高い。
 * ライセンスにより、コネクションの確立数が制限されている場合もある。
 * そのため、コネクションを再利用することには意味がある。
* ただ、一般的にオブジェクトプールはコードを煩雑にし、メモリ量を増加させ、パフォーマンスに悪影響を与える。
* 最新のJVMだと、優秀なGCが備わっているのでオブジェクトプールの管理はしなくていい。

### 防御的コピー

* この項の対象となるのは**防御的コピー**。
* 防御的コピーは項目39で説明されている。
* この項では「既存のオブジェクトを再利用すべき場合には、新たなオブジェクトを生成しない」と述べている。
* 項目39では「新たなオブジェクトを生成すべき場合には、既存のオブジェクトを再利用しない」と述べられている。
* 防御的コピーが求められる場合、「オブジェクトの再利用に対するペナルティ」＞＞「重複したオブジェクトを生成するペナルティ」となる。
* 必要な時に防御的コピーをしなければ、バグやセキュリティホールにつながる。

詳しくは項目39で説明。