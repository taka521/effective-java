# 項目6 廃れたオブジェクト参照を取り除く

GCがあるからと、メモリ管理について考える必要がない...わけではない。<br/>

```java
public class Stack {
    private Object[] elemtns;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack(){
        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object element){
        ensureCapacity();
        elements[size++] = element;
    }
    
    public Object pop(){
        if(size == 0) throw new EmptyStackException();
        return elements[--size];
    }
    
    // 配列を大きくする必要がある場合、約倍の容量に拡張する。
    private void ensureCapacity(){
        if(elements.length == size){
            elements = Arrays.copyOf(element, 2 * size + 1);
        }
    }
}
```

例えばこんなスタック実装があったとして、このスタック実装はメモリリークを引き起こす危険性を秘めている。<br/>
では、どこにメモリリークを引き起こす原因が隠れているのかと言うと...

```java
    public Object pop(){
        if(size == 0) throw new EmptyStackException();
        return elements[--size];
    }
```

この `pop` メソッドがメモリリークを引き起こす原因となる。<br/>
どういうことかと言うと、現状の `pop`メソッドはあくまで `elements` に含まれる要素を返すだけで、そのオブジェクトの参照は `elements` の中に残ったまま。<br/>
スタックのサイズが大きくなってその後小さくなっても、`elements` が保持する参照値は変わらない。<br/>
そのため、参照されなくなったオブジェクトでも `elements` が抱え込んでいるのでGCの対象にならない。<br/>

要は、**廃れた参照**を保持していることでメモリリークを引き起こす。

* オブジェクトの参照が意図されることなく保持されると、そのオブジェクトがGCにより回収されない。
* それに加え、そのオブジェクトを参照しているオブジェクトも回収されなくなる。
* 数個のオブジェクトが意図しない参照の保持により、非常に多くのオブジェクトがGCされずにパフォーマンスに影響が出てくる。

これを解決する簡単な方法は、参照が一度廃れたら**null**を設定すること。
先ほどのスタックにあてはめると、

```java
    public Object pop(){
        if(size == 0) throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // 廃れた参照にはnullを設定する。
        return result;
    }
```

となる。<br/>
スタックは、１つの項目が取り出されると、その項目に対する参照は廃れてしまう。

廃れた参照に対してnullを設定する利点は、

* 仮にそれらの参照が間違って使用された場合、ヌルポでエラーになるため、プログラミングのエラーに気付きやすくなる。

点。<br/>
できるだけ早い段階でミスに気づくことができるのは非常に有益。


## いつnullを設定すべきか

Stackを例に出すと、**Stackの何がメモリリークを引き起こしやすい**のか。<br/>
簡単に言うと、**独自のメモリ管理**を行なっている点。

`elements` という配列にオブジェクトを抱え込んで、`size`未満のインデックスを持つ部分を**有効な要素**、それ以外は**無効な要素**としている。<br/>
プログラマはそれを理解できるが、ガーベジコレクタからすれば `elements`内の要素は**全て有効**と判断される。<br/>
そのため、「不要な参照」であることをガーベジコレクタに知らせるために、廃れた参照にはnullを手で設定してあげるしかない。

このように **独自でメモリ管理を行なっている場合には、メモリリークに対して注意を払う**べき。<br/>
要素が解放されたら、その要素に含まれたオブジェクト参照にはnullを設定しましょう。

## メモリリークの原因 -その2-

メモリリークを引き起こしやすい原因は**キャッシュ**。<br/>
オブジェクトを一旦キャッシュへ入れてしまうと、

* オブジェクトの参照がキャッシュにあることを忘れてしまう。
* オブジェクトへの参照の意味がなくなった場合でも、キャッシュに残ってしまう。

などの問題がある。

これを解決するにはいくつか方法があるが、「キャッシュ外にあるエントリーのキーへの参照が存在する限り、そのエントリーに意味があるキャッシュ」を実装するなら、そのキャッシュは `WeakHashMap` で表現する。<br/>
`WeakHashMap`は、エントリーが廃れてしまうと自動的に取り除かれる。<br/>
キャッシュされるエントリーの生存期間が、値ではなくキーへの外部からの参照によって決定される場合にだけ `WeakHashMap` が有効。

## メモリリークの原因 -その3-

よくある原因の３つめは、**リスナーやコールバック**です。<br/>
クライアントがコールバックを登録するのはいいが、明示的に登録を解除しないAPIを実装すると、コールバックが蓄積されてしまう。<br/>
迅速にコールバックがGCされることを保証する最善の方法は、それらに対する弱い参照だけを保存すること。<br/>
例えば `WeahHashMap` のキーとして、それらを保存するなど。


## まとめ

* 廃れた参照には null を明示的に設定してあげましょう。
* なんでも設定すれば良いわけではなく、独自でメモリ管理を行なっているような場合が対象。
* 参照が不要になった場合に自動的に参照を取り除きたい場合には、`WeakHashMap` を使用すると良い。




